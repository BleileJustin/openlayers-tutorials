import {
  RenderTarget_default,
  WebGLWorkerMessageType,
  create as create3,
  getWorldParameters
} from "./chunk-PYDP63R2.js";
import {
  ARRAY_BUFFER,
  AttributeType,
  Buffer_default,
  DYNAMIC_DRAW,
  DefaultUniform,
  ELEMENT_ARRAY_BUFFER,
  Layer_default,
  colorDecodeId,
  colorEncodeId,
  create as create2,
  fromTransform,
  parseLiteralStyle
} from "./chunk-H75M6Q5V.js";
import "./chunk-ZBHYUMJP.js";
import "./chunk-4Q6CBNQ3.js";
import "./chunk-U2MRU5GJ.js";
import "./chunk-OSZ3F7K3.js";
import "./chunk-5D2XPBR2.js";
import {
  BaseVector_default
} from "./chunk-N6PBDKPB.js";
import "./chunk-X3CXXPKT.js";
import "./chunk-5FJK53SP.js";
import "./chunk-O65DGZWO.js";
import "./chunk-KH4U264D.js";
import "./chunk-JQFVMYPR.js";
import "./chunk-W67OYE6V.js";
import "./chunk-ANEG4C4P.js";
import "./chunk-HAW5CPRO.js";
import "./chunk-V534IWZB.js";
import {
  VectorEventType_default
} from "./chunk-V7WRBSQ6.js";
import {
  Feature_default2 as Feature_default
} from "./chunk-S7OHK4LU.js";
import "./chunk-JT33CQTS.js";
import "./chunk-JFXZSSOM.js";
import {
  ViewHint_default
} from "./chunk-R6INQWDG.js";
import "./chunk-FM44FOIC.js";
import "./chunk-LMC3RO5P.js";
import {
  apply,
  create,
  inflateEnds,
  makeInverse,
  multiply,
  setFromArray,
  transform2D,
  translate
} from "./chunk-FCZQVTDO.js";
import "./chunk-ULLHK4LG.js";
import {
  assert
} from "./chunk-7UJ7GXUX.js";
import {
  buffer,
  createEmpty,
  equals,
  getTransformFromProjections,
  getUserProjection,
  toUserExtent,
  toUserResolution
} from "./chunk-KUZT6UQG.js";
import {
  getUid,
  listen,
  unlistenByKey
} from "./chunk-QWLF7CK3.js";
import "./chunk-7VZEFDV7.js";
import "./chunk-ZS7NZCD4.js";

// node_modules/ol/render/webgl/MixedGeometryBatch.js
var MixedGeometryBatch = class {
  constructor() {
    this.globalCounter_ = 0;
    this.refToFeature_ = /* @__PURE__ */ new Map();
    this.uidToRef_ = /* @__PURE__ */ new Map();
    this.freeGlobalRef_ = [];
    this.polygonBatch = {
      entries: {},
      geometriesCount: 0,
      verticesCount: 0,
      ringsCount: 0
    };
    this.pointBatch = {
      entries: {},
      geometriesCount: 0
    };
    this.lineStringBatch = {
      entries: {},
      geometriesCount: 0,
      verticesCount: 0
    };
  }
  /**
   * @param {Array<Feature|RenderFeature>} features Array of features to add to the batch
   * @param {import("../../proj.js").TransformFunction} [projectionTransform] Projection transform.
   */
  addFeatures(features, projectionTransform) {
    for (let i = 0; i < features.length; i++) {
      this.addFeature(features[i], projectionTransform);
    }
  }
  /**
   * @param {Feature|RenderFeature} feature Feature to add to the batch
   * @param {import("../../proj.js").TransformFunction} [projectionTransform] Projection transform.
   */
  addFeature(feature, projectionTransform) {
    let geometry = feature.getGeometry();
    if (!geometry) {
      return;
    }
    if (projectionTransform) {
      geometry = geometry.clone();
      geometry.applyTransform(projectionTransform);
    }
    this.addGeometry_(geometry, feature);
  }
  /**
   * @param {Feature|RenderFeature} feature Feature
   * @return {GeometryBatchItem|void} the cleared entry
   * @private
   */
  clearFeatureEntryInPointBatch_(feature) {
    const entry = this.pointBatch.entries[getUid(feature)];
    if (!entry) {
      return;
    }
    this.pointBatch.geometriesCount -= entry.flatCoordss.length;
    delete this.pointBatch.entries[getUid(feature)];
    return entry;
  }
  /**
   * @param {Feature|RenderFeature} feature Feature
   * @return {GeometryBatchItem|void} the cleared entry
   * @private
   */
  clearFeatureEntryInLineStringBatch_(feature) {
    const entry = this.lineStringBatch.entries[getUid(feature)];
    if (!entry) {
      return;
    }
    this.lineStringBatch.verticesCount -= entry.verticesCount;
    this.lineStringBatch.geometriesCount -= entry.flatCoordss.length;
    delete this.lineStringBatch.entries[getUid(feature)];
    return entry;
  }
  /**
   * @param {Feature|RenderFeature} feature Feature
   * @return {GeometryBatchItem|void} the cleared entry
   * @private
   */
  clearFeatureEntryInPolygonBatch_(feature) {
    const entry = this.polygonBatch.entries[getUid(feature)];
    if (!entry) {
      return;
    }
    this.polygonBatch.verticesCount -= entry.verticesCount;
    this.polygonBatch.ringsCount -= entry.ringsCount;
    this.polygonBatch.geometriesCount -= entry.flatCoordss.length;
    delete this.polygonBatch.entries[getUid(feature)];
    return entry;
  }
  /**
   * @param {import("../../geom.js").Geometry|RenderFeature} geometry Geometry
   * @param {Feature|RenderFeature} feature Feature
   * @private
   */
  addGeometry_(geometry, feature) {
    const type = geometry.getType();
    switch (type) {
      case "GeometryCollection": {
        const geometries = (
          /** @type {import("../../geom.js").GeometryCollection} */
          geometry.getGeometriesArray()
        );
        for (const geometry2 of geometries) {
          this.addGeometry_(geometry2, feature);
        }
        break;
      }
      case "MultiPolygon": {
        const multiPolygonGeom = (
          /** @type {import("../../geom.js").MultiPolygon} */
          geometry
        );
        this.addCoordinates_(
          type,
          multiPolygonGeom.getFlatCoordinates(),
          multiPolygonGeom.getEndss(),
          feature,
          getUid(feature),
          multiPolygonGeom.getStride()
        );
        break;
      }
      case "MultiLineString": {
        const multiLineGeom = (
          /** @type {import("../../geom.js").MultiLineString|RenderFeature} */
          geometry
        );
        this.addCoordinates_(
          type,
          multiLineGeom.getFlatCoordinates(),
          multiLineGeom.getEnds(),
          feature,
          getUid(feature),
          multiLineGeom.getStride()
        );
        break;
      }
      case "MultiPoint": {
        const multiPointGeom = (
          /** @type {import("../../geom.js").MultiPoint|RenderFeature} */
          geometry
        );
        this.addCoordinates_(
          type,
          multiPointGeom.getFlatCoordinates(),
          null,
          feature,
          getUid(feature),
          multiPointGeom.getStride()
        );
        break;
      }
      case "Polygon": {
        const polygonGeom = (
          /** @type {import("../../geom.js").Polygon|RenderFeature} */
          geometry
        );
        this.addCoordinates_(
          type,
          polygonGeom.getFlatCoordinates(),
          polygonGeom.getEnds(),
          feature,
          getUid(feature),
          polygonGeom.getStride()
        );
        break;
      }
      case "Point": {
        const pointGeom = (
          /** @type {import("../../geom.js").Point} */
          geometry
        );
        this.addCoordinates_(
          type,
          pointGeom.getFlatCoordinates(),
          null,
          feature,
          getUid(feature),
          pointGeom.getStride()
        );
        break;
      }
      case "LineString":
      case "LinearRing": {
        const lineGeom = (
          /** @type {import("../../geom.js").LineString} */
          geometry
        );
        this.addCoordinates_(
          type,
          lineGeom.getFlatCoordinates(),
          null,
          feature,
          getUid(feature),
          lineGeom.getStride()
        );
        break;
      }
      default:
    }
  }
  /**
   * @param {GeometryType} type Geometry type
   * @param {Array<number>} flatCoords Flat coordinates
   * @param {Array<number> | Array<Array<number>> | null} ends Coordinate ends
   * @param {Feature|RenderFeature} feature Feature
   * @param {string} featureUid Feature uid
   * @param {number} stride Stride
   * @private
   */
  addCoordinates_(type, flatCoords, ends, feature, featureUid, stride) {
    let verticesCount;
    switch (type) {
      case "MultiPolygon": {
        const multiPolygonEndss = (
          /** @type {Array<Array<number>>} */
          ends
        );
        for (let i = 0, ii = multiPolygonEndss.length; i < ii; i++) {
          let polygonEnds = multiPolygonEndss[i];
          const prevPolygonEnds = i > 0 ? multiPolygonEndss[i - 1] : null;
          const startIndex = prevPolygonEnds ? prevPolygonEnds[prevPolygonEnds.length - 1] : 0;
          const endIndex = polygonEnds[polygonEnds.length - 1];
          polygonEnds = startIndex > 0 ? polygonEnds.map((end) => end - startIndex) : polygonEnds;
          this.addCoordinates_(
            "Polygon",
            flatCoords.slice(startIndex, endIndex),
            polygonEnds,
            feature,
            featureUid,
            stride
          );
        }
        break;
      }
      case "MultiLineString": {
        const multiLineEnds = (
          /** @type {Array<number>} */
          ends
        );
        for (let i = 0, ii = multiLineEnds.length; i < ii; i++) {
          const startIndex = i > 0 ? multiLineEnds[i - 1] : 0;
          this.addCoordinates_(
            "LineString",
            flatCoords.slice(startIndex, multiLineEnds[i]),
            null,
            feature,
            featureUid,
            stride
          );
        }
        break;
      }
      case "MultiPoint":
        for (let i = 0, ii = flatCoords.length; i < ii; i += stride) {
          this.addCoordinates_(
            "Point",
            flatCoords.slice(i, i + 2),
            null,
            feature,
            featureUid,
            null
          );
        }
        break;
      case "Polygon": {
        const polygonEnds = (
          /** @type {Array<number>} */
          ends
        );
        if (feature instanceof Feature_default) {
          const multiPolygonEnds = inflateEnds(flatCoords, polygonEnds);
          if (multiPolygonEnds.length > 1) {
            this.addCoordinates_(
              "MultiPolygon",
              flatCoords,
              multiPolygonEnds,
              feature,
              featureUid,
              stride
            );
            return;
          }
        }
        if (!this.polygonBatch.entries[featureUid]) {
          this.polygonBatch.entries[featureUid] = this.addRefToEntry_(
            featureUid,
            {
              feature,
              flatCoordss: [],
              verticesCount: 0,
              ringsCount: 0,
              ringsVerticesCounts: []
            }
          );
        }
        verticesCount = flatCoords.length / stride;
        const ringsCount = ends.length;
        const ringsVerticesCount = ends.map(
          (end, ind, arr) => ind > 0 ? (end - arr[ind - 1]) / stride : end / stride
        );
        this.polygonBatch.verticesCount += verticesCount;
        this.polygonBatch.ringsCount += ringsCount;
        this.polygonBatch.geometriesCount++;
        this.polygonBatch.entries[featureUid].flatCoordss.push(
          getFlatCoordinatesXY(flatCoords, stride)
        );
        this.polygonBatch.entries[featureUid].ringsVerticesCounts.push(
          ringsVerticesCount
        );
        this.polygonBatch.entries[featureUid].verticesCount += verticesCount;
        this.polygonBatch.entries[featureUid].ringsCount += ringsCount;
        for (let i = 0, ii = polygonEnds.length; i < ii; i++) {
          const startIndex = i > 0 ? polygonEnds[i - 1] : 0;
          this.addCoordinates_(
            "LinearRing",
            flatCoords.slice(startIndex, polygonEnds[i]),
            null,
            feature,
            featureUid,
            stride
          );
        }
        break;
      }
      case "Point":
        if (!this.pointBatch.entries[featureUid]) {
          this.pointBatch.entries[featureUid] = this.addRefToEntry_(
            featureUid,
            {
              feature,
              flatCoordss: []
            }
          );
        }
        this.pointBatch.geometriesCount++;
        this.pointBatch.entries[featureUid].flatCoordss.push(flatCoords);
        break;
      case "LineString":
      case "LinearRing":
        if (!this.lineStringBatch.entries[featureUid]) {
          this.lineStringBatch.entries[featureUid] = this.addRefToEntry_(
            featureUid,
            {
              feature,
              flatCoordss: [],
              verticesCount: 0
            }
          );
        }
        verticesCount = flatCoords.length / stride;
        this.lineStringBatch.verticesCount += verticesCount;
        this.lineStringBatch.geometriesCount++;
        this.lineStringBatch.entries[featureUid].flatCoordss.push(
          getFlatCoordinatesXY(flatCoords, stride)
        );
        this.lineStringBatch.entries[featureUid].verticesCount += verticesCount;
        break;
      default:
    }
  }
  /**
   * @param {string} featureUid Feature uid
   * @param {GeometryBatchItem} entry The entry to add
   * @return {GeometryBatchItem} the added entry
   * @private
   */
  addRefToEntry_(featureUid, entry) {
    const currentRef = this.uidToRef_.get(featureUid);
    const ref = currentRef || this.freeGlobalRef_.pop() || ++this.globalCounter_;
    entry.ref = ref;
    if (!currentRef) {
      this.refToFeature_.set(ref, entry.feature);
      this.uidToRef_.set(featureUid, ref);
    }
    return entry;
  }
  /**
   * Return a ref to the pool of available refs.
   * @param {number} ref the ref to return
   * @param {string} featureUid the feature uid
   * @private
   */
  returnRef_(ref, featureUid) {
    if (!ref) {
      throw new Error("This feature has no ref: " + featureUid);
    }
    this.refToFeature_.delete(ref);
    this.uidToRef_.delete(featureUid);
    this.freeGlobalRef_.push(ref);
  }
  /**
   * @param {Feature|RenderFeature} feature Feature
   */
  changeFeature(feature) {
    this.removeFeature(feature);
    const geometry = feature.getGeometry();
    if (!geometry) {
      return;
    }
    this.addGeometry_(geometry, feature);
  }
  /**
   * @param {Feature|RenderFeature} feature Feature
   */
  removeFeature(feature) {
    let entry;
    entry = this.clearFeatureEntryInPointBatch_(feature) || entry;
    entry = this.clearFeatureEntryInPolygonBatch_(feature) || entry;
    entry = this.clearFeatureEntryInLineStringBatch_(feature) || entry;
    if (entry) {
      this.returnRef_(entry.ref, getUid(entry.feature));
    }
  }
  clear() {
    this.polygonBatch.entries = {};
    this.polygonBatch.geometriesCount = 0;
    this.polygonBatch.verticesCount = 0;
    this.polygonBatch.ringsCount = 0;
    this.lineStringBatch.entries = {};
    this.lineStringBatch.geometriesCount = 0;
    this.lineStringBatch.verticesCount = 0;
    this.pointBatch.entries = {};
    this.pointBatch.geometriesCount = 0;
    this.globalCounter_ = 0;
    this.freeGlobalRef_ = [];
    this.refToFeature_.clear();
    this.uidToRef_.clear();
  }
  /**
   * Resolve the feature associated to a ref.
   * @param {number} ref Hit detected ref
   * @return {Feature|RenderFeature} feature
   */
  getFeatureFromRef(ref) {
    return this.refToFeature_.get(ref);
  }
};
function getFlatCoordinatesXY(flatCoords, stride) {
  if (stride === 2) {
    return flatCoords;
  }
  return flatCoords.filter((v, i) => i % stride < 2);
}
var MixedGeometryBatch_default = MixedGeometryBatch;

// node_modules/ol/render/webgl/renderinstructions.js
function pushCustomAttributesInRenderInstructions(renderInstructions, customAttributes, batchEntry, currentIndex) {
  let shift = 0;
  for (const key in customAttributes) {
    const attr = customAttributes[key];
    const value = attr.callback.call(batchEntry, batchEntry.feature);
    renderInstructions[currentIndex + shift++] = value[0] ?? value;
    if (!attr.size || attr.size === 1) {
      continue;
    }
    renderInstructions[currentIndex + shift++] = value[1];
    if (attr.size < 3) {
      continue;
    }
    renderInstructions[currentIndex + shift++] = value[2];
    if (attr.size < 4) {
      continue;
    }
    renderInstructions[currentIndex + shift++] = value[3];
  }
  return shift;
}
function getCustomAttributesSize(customAttributes) {
  return Object.keys(customAttributes).reduce(
    (prev, curr) => prev + (customAttributes[curr].size || 1),
    0
  );
}
function generatePointRenderInstructions(batch, renderInstructions, customAttributes, transform) {
  const totalInstructionsCount = (2 + getCustomAttributesSize(customAttributes)) * batch.geometriesCount;
  if (!renderInstructions || renderInstructions.length !== totalInstructionsCount) {
    renderInstructions = new Float32Array(totalInstructionsCount);
  }
  const tmpCoords = [];
  let renderIndex = 0;
  for (const featureUid in batch.entries) {
    const batchEntry = batch.entries[featureUid];
    for (let i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {
      tmpCoords[0] = batchEntry.flatCoordss[i][0];
      tmpCoords[1] = batchEntry.flatCoordss[i][1];
      apply(transform, tmpCoords);
      renderInstructions[renderIndex++] = tmpCoords[0];
      renderInstructions[renderIndex++] = tmpCoords[1];
      renderIndex += pushCustomAttributesInRenderInstructions(
        renderInstructions,
        customAttributes,
        batchEntry,
        renderIndex
      );
    }
  }
  return renderInstructions;
}
function generateLineStringRenderInstructions(batch, renderInstructions, customAttributes, transform) {
  const totalInstructionsCount = 2 * batch.verticesCount + (1 + getCustomAttributesSize(customAttributes)) * batch.geometriesCount;
  if (!renderInstructions || renderInstructions.length !== totalInstructionsCount) {
    renderInstructions = new Float32Array(totalInstructionsCount);
  }
  const flatCoords = [];
  let renderIndex = 0;
  for (const featureUid in batch.entries) {
    const batchEntry = batch.entries[featureUid];
    for (let i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {
      flatCoords.length = batchEntry.flatCoordss[i].length;
      transform2D(
        batchEntry.flatCoordss[i],
        0,
        flatCoords.length,
        2,
        transform,
        flatCoords
      );
      renderIndex += pushCustomAttributesInRenderInstructions(
        renderInstructions,
        customAttributes,
        batchEntry,
        renderIndex
      );
      renderInstructions[renderIndex++] = flatCoords.length / 2;
      for (let j = 0, jj = flatCoords.length; j < jj; j += 2) {
        renderInstructions[renderIndex++] = flatCoords[j];
        renderInstructions[renderIndex++] = flatCoords[j + 1];
      }
    }
  }
  return renderInstructions;
}
function generatePolygonRenderInstructions(batch, renderInstructions, customAttributes, transform) {
  const totalInstructionsCount = 2 * batch.verticesCount + (1 + getCustomAttributesSize(customAttributes)) * batch.geometriesCount + batch.ringsCount;
  if (!renderInstructions || renderInstructions.length !== totalInstructionsCount) {
    renderInstructions = new Float32Array(totalInstructionsCount);
  }
  const flatCoords = [];
  let renderIndex = 0;
  for (const featureUid in batch.entries) {
    const batchEntry = batch.entries[featureUid];
    for (let i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {
      flatCoords.length = batchEntry.flatCoordss[i].length;
      transform2D(
        batchEntry.flatCoordss[i],
        0,
        flatCoords.length,
        2,
        transform,
        flatCoords
      );
      renderIndex += pushCustomAttributesInRenderInstructions(
        renderInstructions,
        customAttributes,
        batchEntry,
        renderIndex
      );
      renderInstructions[renderIndex++] = batchEntry.ringsVerticesCounts[i].length;
      for (let j = 0, jj = batchEntry.ringsVerticesCounts[i].length; j < jj; j++) {
        renderInstructions[renderIndex++] = batchEntry.ringsVerticesCounts[i][j];
      }
      for (let j = 0, jj = flatCoords.length; j < jj; j += 2) {
        renderInstructions[renderIndex++] = flatCoords[j];
        renderInstructions[renderIndex++] = flatCoords[j + 1];
      }
    }
  }
  return renderInstructions;
}

// node_modules/ol/render/webgl/VectorStyleRenderer.js
var tmpColor = [];
var WEBGL_WORKER = create3();
var workerMessageCounter = 0;
var Attributes = {
  POSITION: "a_position",
  INDEX: "a_index",
  SEGMENT_START: "a_segmentStart",
  SEGMENT_END: "a_segmentEnd",
  PARAMETERS: "a_parameters",
  JOIN_ANGLES: "a_joinAngles",
  DISTANCE: "a_distance"
};
var VectorStyleRenderer = class {
  /**
   * @param {VectorStyle} styleOrShaders Literal style or custom shaders
   * @param {import('../../webgl/Helper.js').default} helper Helper
   * @param {boolean} enableHitDetection Whether to enable the hit detection (needs compatible shader)
   */
  constructor(styleOrShaders, helper, enableHitDetection) {
    this.helper_ = helper;
    this.hitDetectionEnabled_ = enableHitDetection;
    let shaders = (
      /** @type {StyleShaders} */
      styleOrShaders
    );
    const isShaders = "builder" in styleOrShaders;
    if (!isShaders) {
      const parseResult = parseLiteralStyle(
        /** @type {import('../../style/webgl.js').WebGLStyle} */
        styleOrShaders
      );
      shaders = {
        builder: parseResult.builder,
        attributes: parseResult.attributes,
        uniforms: parseResult.uniforms
      };
    }
    this.hasFill_ = !!shaders.builder.getFillVertexShader();
    if (this.hasFill_) {
      this.fillVertexShader_ = shaders.builder.getFillVertexShader();
      this.fillFragmentShader_ = shaders.builder.getFillFragmentShader();
      this.fillProgram_ = this.helper_.getProgram(
        this.fillFragmentShader_,
        this.fillVertexShader_
      );
    }
    this.hasStroke_ = !!shaders.builder.getStrokeVertexShader();
    if (this.hasStroke_) {
      this.strokeVertexShader_ = shaders.builder.getStrokeVertexShader();
      this.strokeFragmentShader_ = shaders.builder.getStrokeFragmentShader();
      this.strokeProgram_ = this.helper_.getProgram(
        this.strokeFragmentShader_,
        this.strokeVertexShader_
      );
    }
    this.hasSymbol_ = !!shaders.builder.getSymbolVertexShader();
    if (this.hasSymbol_) {
      this.symbolVertexShader_ = shaders.builder.getSymbolVertexShader();
      this.symbolFragmentShader_ = shaders.builder.getSymbolFragmentShader();
      this.symbolProgram_ = this.helper_.getProgram(
        this.symbolFragmentShader_,
        this.symbolVertexShader_
      );
    }
    const hitDetectionAttributes = this.hitDetectionEnabled_ ? {
      hitColor: {
        callback() {
          return colorEncodeId(this.ref, tmpColor);
        },
        size: 4
      }
    } : {};
    this.customAttributes_ = Object.assign(
      {},
      hitDetectionAttributes,
      shaders.attributes
    );
    this.uniforms_ = shaders.uniforms;
    const customAttributesDesc = Object.entries(this.customAttributes_).map(
      ([name, value]) => ({
        name: `a_prop_${name}`,
        size: value.size || 1,
        type: AttributeType.FLOAT
      })
    );
    this.polygonAttributesDesc_ = [
      {
        name: Attributes.POSITION,
        size: 2,
        type: AttributeType.FLOAT
      },
      ...customAttributesDesc
    ];
    this.lineStringAttributesDesc_ = [
      {
        name: Attributes.SEGMENT_START,
        size: 2,
        type: AttributeType.FLOAT
      },
      {
        name: Attributes.SEGMENT_END,
        size: 2,
        type: AttributeType.FLOAT
      },
      {
        name: Attributes.JOIN_ANGLES,
        size: 2,
        type: AttributeType.FLOAT
      },
      {
        name: Attributes.DISTANCE,
        size: 1,
        type: AttributeType.FLOAT
      },
      {
        name: Attributes.PARAMETERS,
        size: 1,
        type: AttributeType.FLOAT
      },
      ...customAttributesDesc
    ];
    this.pointAttributesDesc_ = [
      {
        name: Attributes.POSITION,
        size: 2,
        type: AttributeType.FLOAT
      },
      {
        name: Attributes.INDEX,
        size: 1,
        type: AttributeType.FLOAT
      },
      ...customAttributesDesc
    ];
    if (shaders.uniforms) {
      this.helper_.addUniforms(shaders.uniforms);
    }
  }
  /**
   * @param {import('./MixedGeometryBatch.js').default} geometryBatch Geometry batch
   * @param {import("../../transform.js").Transform} transform Transform to apply to coordinates
   * @return {Promise<WebGLBuffers>} A promise resolving to WebGL buffers
   */
  async generateBuffers(geometryBatch, transform) {
    const renderInstructions = this.generateRenderInstructions_(
      geometryBatch,
      transform
    );
    const [polygonBuffers, lineStringBuffers, pointBuffers] = await Promise.all(
      [
        this.generateBuffersForType_(
          renderInstructions.polygonInstructions,
          "Polygon",
          transform
        ),
        this.generateBuffersForType_(
          renderInstructions.lineStringInstructions,
          "LineString",
          transform
        ),
        this.generateBuffersForType_(
          renderInstructions.pointInstructions,
          "Point",
          transform
        )
      ]
    );
    const invertVerticesTransform = makeInverse(
      create(),
      transform
    );
    return {
      polygonBuffers,
      lineStringBuffers,
      pointBuffers,
      invertVerticesTransform
    };
  }
  /**
   * @param {import('./MixedGeometryBatch.js').default} geometryBatch Geometry batch
   * @param {import("../../transform.js").Transform} transform Transform to apply to coordinates
   * @return {RenderInstructions} Render instructions
   * @private
   */
  generateRenderInstructions_(geometryBatch, transform) {
    const polygonInstructions = this.hasFill_ ? generatePolygonRenderInstructions(
      geometryBatch.polygonBatch,
      new Float32Array(0),
      this.customAttributes_,
      transform
    ) : null;
    const lineStringInstructions = this.hasStroke_ ? generateLineStringRenderInstructions(
      geometryBatch.lineStringBatch,
      new Float32Array(0),
      this.customAttributes_,
      transform
    ) : null;
    const pointInstructions = this.hasSymbol_ ? generatePointRenderInstructions(
      geometryBatch.pointBatch,
      new Float32Array(0),
      this.customAttributes_,
      transform
    ) : null;
    return {
      polygonInstructions,
      lineStringInstructions,
      pointInstructions
    };
  }
  /**
   * @param {Float32Array|null} renderInstructions Render instructions
   * @param {import("../../geom/Geometry.js").Type} geometryType Geometry type
   * @param {import("../../transform.js").Transform} transform Transform to apply to coordinates
   * @return {Promise<Array<WebGLArrayBuffer>>|null} Indices buffer and vertices buffer; null if nothing to render
   * @private
   */
  generateBuffersForType_(renderInstructions, geometryType, transform) {
    if (renderInstructions === null) {
      return null;
    }
    const messageId = workerMessageCounter++;
    let messageType;
    switch (geometryType) {
      case "Polygon":
        messageType = WebGLWorkerMessageType.GENERATE_POLYGON_BUFFERS;
        break;
      case "LineString":
        messageType = WebGLWorkerMessageType.GENERATE_LINE_STRING_BUFFERS;
        break;
      case "Point":
        messageType = WebGLWorkerMessageType.GENERATE_POINT_BUFFERS;
        break;
      default:
    }
    const message = {
      id: messageId,
      type: messageType,
      renderInstructions: renderInstructions.buffer,
      renderInstructionsTransform: transform,
      customAttributesSize: getCustomAttributesSize(this.customAttributes_)
    };
    WEBGL_WORKER.postMessage(message, [renderInstructions.buffer]);
    renderInstructions = null;
    return new Promise((resolve) => {
      const handleMessage = (event) => {
        const received = event.data;
        if (received.id !== messageId) {
          return;
        }
        WEBGL_WORKER.removeEventListener("message", handleMessage);
        if (!this.helper_.getGL()) {
          return;
        }
        const verticesBuffer = new Buffer_default(
          ARRAY_BUFFER,
          DYNAMIC_DRAW
        ).fromArrayBuffer(received.vertexBuffer);
        const indicesBuffer = new Buffer_default(
          ELEMENT_ARRAY_BUFFER,
          DYNAMIC_DRAW
        ).fromArrayBuffer(received.indexBuffer);
        this.helper_.flushBufferData(verticesBuffer);
        this.helper_.flushBufferData(indicesBuffer);
        resolve([indicesBuffer, verticesBuffer]);
      };
      WEBGL_WORKER.addEventListener("message", handleMessage);
    });
  }
  /**
   * Render the geometries in the given buffers.
   * @param {WebGLBuffers} buffers WebGL Buffers to draw
   * @param {import("../../Map.js").FrameState} frameState Frame state
   * @param {function(): void} preRenderCallback This callback will be called right before drawing, and can be used to set uniforms
   */
  render(buffers, frameState, preRenderCallback) {
    this.hasFill_ && this.renderInternal_(
      buffers.polygonBuffers[0],
      buffers.polygonBuffers[1],
      this.fillProgram_,
      this.polygonAttributesDesc_,
      frameState,
      preRenderCallback
    );
    this.hasStroke_ && this.renderInternal_(
      buffers.lineStringBuffers[0],
      buffers.lineStringBuffers[1],
      this.strokeProgram_,
      this.lineStringAttributesDesc_,
      frameState,
      preRenderCallback
    );
    this.hasSymbol_ && this.renderInternal_(
      buffers.pointBuffers[0],
      buffers.pointBuffers[1],
      this.symbolProgram_,
      this.pointAttributesDesc_,
      frameState,
      preRenderCallback
    );
  }
  /**
   * @param {WebGLArrayBuffer} indicesBuffer Indices buffer
   * @param {WebGLArrayBuffer} verticesBuffer Vertices buffer
   * @param {WebGLProgram} program Program
   * @param {Array<import('../../webgl/Helper.js').AttributeDescription>} attributes Attribute descriptions
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {function(): void} preRenderCallback This callback will be called right before drawing, and can be used to set uniforms
   * @private
   */
  renderInternal_(indicesBuffer, verticesBuffer, program, attributes, frameState, preRenderCallback) {
    const renderCount = indicesBuffer.getSize();
    if (renderCount === 0) {
      return;
    }
    this.helper_.useProgram(program, frameState);
    this.helper_.bindBuffer(verticesBuffer);
    this.helper_.bindBuffer(indicesBuffer);
    this.helper_.enableAttributes(attributes);
    preRenderCallback();
    this.helper_.drawElements(0, renderCount);
  }
};
var VectorStyleRenderer_default = VectorStyleRenderer;

// node_modules/ol/renderer/webgl/VectorLayer.js
var Uniforms = {
  ...DefaultUniform,
  RENDER_EXTENT: "u_renderExtent",
  // intersection of layer, source, and view extent
  PATTERN_ORIGIN: "u_patternOrigin",
  GLOBAL_ALPHA: "u_globalAlpha"
};
var WebGLVectorLayerRenderer = class extends Layer_default {
  /**
   * @param {import("../../layer/Layer.js").default} layer Layer.
   * @param {Options} options Options.
   */
  constructor(layer, options) {
    const uniforms = {
      [Uniforms.RENDER_EXTENT]: [0, 0, 0, 0],
      [Uniforms.PATTERN_ORIGIN]: [0, 0],
      [Uniforms.GLOBAL_ALPHA]: 1
    };
    super(layer, {
      uniforms,
      postProcesses: options.postProcesses
    });
    this.hitDetectionEnabled_ = !options.disableHitDetection;
    this.hitRenderTarget_;
    this.sourceRevision_ = -1;
    this.previousExtent_ = createEmpty();
    this.currentTransform_ = create();
    this.tmpCoords_ = [0, 0];
    this.tmpTransform_ = create();
    this.tmpMat4_ = create2();
    this.currentFrameStateTransform_ = create();
    this.styles_ = [];
    this.styleRenderers_ = [];
    this.buffers_ = [];
    this.applyOptions_(options);
    this.batch_ = new MixedGeometryBatch_default();
    this.initialFeaturesAdded_ = false;
    this.sourceListenKeys_ = null;
  }
  /**
   * @private
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  addInitialFeatures_(frameState) {
    const source = this.getLayer().getSource();
    const userProjection = getUserProjection();
    let projectionTransform;
    if (userProjection) {
      projectionTransform = getTransformFromProjections(
        userProjection,
        frameState.viewState.projection
      );
    }
    this.batch_.addFeatures(source.getFeatures(), projectionTransform);
    this.sourceListenKeys_ = [
      listen(
        source,
        VectorEventType_default.ADDFEATURE,
        this.handleSourceFeatureAdded_.bind(this, projectionTransform),
        this
      ),
      listen(
        source,
        VectorEventType_default.CHANGEFEATURE,
        this.handleSourceFeatureChanged_,
        this
      ),
      listen(
        source,
        VectorEventType_default.REMOVEFEATURE,
        this.handleSourceFeatureDelete_,
        this
      ),
      listen(
        source,
        VectorEventType_default.CLEAR,
        this.handleSourceFeatureClear_,
        this
      )
    ];
  }
  /**
   * @param {Options} options Options.
   * @private
   */
  applyOptions_(options) {
    this.styles_ = Array.isArray(options.style) ? options.style : [options.style];
  }
  /**
   * @private
   */
  createRenderers_() {
    this.buffers_ = [];
    this.styleRenderers_ = this.styles_.map(
      (style) => new VectorStyleRenderer_default(style, this.helper, this.hitDetectionEnabled_)
    );
  }
  reset(options) {
    this.applyOptions_(options);
    if (this.helper) {
      this.createRenderers_();
    }
    super.reset(options);
  }
  afterHelperCreated() {
    this.createRenderers_();
    if (this.hitDetectionEnabled_) {
      this.hitRenderTarget_ = new RenderTarget_default(this.helper);
    }
  }
  /**
   * @param {import("../../proj.js").TransformFunction} projectionTransform Transform function.
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureAdded_(projectionTransform, event) {
    const feature = event.feature;
    this.batch_.addFeature(feature, projectionTransform);
  }
  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureChanged_(event) {
    const feature = event.feature;
    this.batch_.changeFeature(feature);
  }
  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureDelete_(event) {
    const feature = event.feature;
    this.batch_.removeFeature(feature);
  }
  /**
   * @private
   */
  handleSourceFeatureClear_() {
    this.batch_.clear();
  }
  /**
   * @param {import("../../transform.js").Transform} batchInvertTransform Inverse of the transformation in which geometries are expressed
   * @private
   */
  applyUniforms_(batchInvertTransform) {
    setFromArray(this.tmpTransform_, this.currentFrameStateTransform_);
    multiply(this.tmpTransform_, batchInvertTransform);
    this.helper.setUniformMatrixValue(
      Uniforms.PROJECTION_MATRIX,
      fromTransform(this.tmpMat4_, this.tmpTransform_)
    );
    makeInverse(this.tmpTransform_, this.tmpTransform_);
    this.helper.setUniformMatrixValue(
      Uniforms.SCREEN_TO_WORLD_MATRIX,
      fromTransform(this.tmpMat4_, this.tmpTransform_)
    );
    this.tmpCoords_[0] = 0;
    this.tmpCoords_[1] = 0;
    makeInverse(this.tmpTransform_, batchInvertTransform);
    apply(this.tmpTransform_, this.tmpCoords_);
    this.helper.setUniformFloatVec2(Uniforms.PATTERN_ORIGIN, this.tmpCoords_);
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(frameState) {
    const gl = this.helper.getGL();
    this.preRender(gl, frameState);
    const [startWorld, endWorld, worldWidth] = getWorldParameters(
      frameState,
      this.getLayer()
    );
    this.helper.prepareDraw(frameState);
    this.renderWorlds(frameState, false, startWorld, endWorld, worldWidth);
    this.helper.finalizeDraw(frameState);
    const canvas = this.helper.getCanvas();
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const opacity = layerState.opacity;
    if (opacity !== parseFloat(canvas.style.opacity)) {
      canvas.style.opacity = String(opacity);
    }
    if (this.hitDetectionEnabled_) {
      this.renderWorlds(frameState, true, startWorld, endWorld, worldWidth);
      this.hitRenderTarget_.clearCachedData();
    }
    this.postRender(gl, frameState);
    return canvas;
  }
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrameInternal(frameState) {
    if (!this.initialFeaturesAdded_) {
      this.addInitialFeatures_(frameState);
      this.initialFeaturesAdded_ = true;
    }
    const layer = this.getLayer();
    const vectorSource = layer.getSource();
    const viewState = frameState.viewState;
    const viewNotMoving = !frameState.viewHints[ViewHint_default.ANIMATING] && !frameState.viewHints[ViewHint_default.INTERACTING];
    const extentChanged = !equals(this.previousExtent_, frameState.extent);
    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();
    if (sourceChanged) {
      this.sourceRevision_ = vectorSource.getRevision();
    }
    if (viewNotMoving && (extentChanged || sourceChanged)) {
      const projection = viewState.projection;
      const resolution = viewState.resolution;
      const renderBuffer = layer instanceof BaseVector_default ? layer.getRenderBuffer() : 0;
      const extent = buffer(frameState.extent, renderBuffer * resolution);
      const userProjection = getUserProjection();
      if (userProjection) {
        vectorSource.loadFeatures(
          toUserExtent(extent, userProjection),
          toUserResolution(resolution, projection),
          userProjection
        );
      } else {
        vectorSource.loadFeatures(extent, resolution, projection);
      }
      this.ready = false;
      const transform = this.helper.makeProjectionTransform(
        frameState,
        create()
      );
      const generatePromises = this.styleRenderers_.map(
        (renderer, i) => renderer.generateBuffers(this.batch_, transform).then((buffers) => {
          this.buffers_[i] = buffers;
        })
      );
      Promise.all(generatePromises).then(() => {
        this.ready = true;
        this.getLayer().changed();
      });
      this.previousExtent_ = frameState.extent.slice();
    }
    return true;
  }
  /**
   * Render the world, either to the main framebuffer or to the hit framebuffer
   * @param {import("../../Map.js").FrameState} frameState current frame state
   * @param {boolean} forHitDetection whether the rendering is for hit detection
   * @param {number} startWorld the world to render in the first iteration
   * @param {number} endWorld the last world to render
   * @param {number} worldWidth the width of the worlds being rendered
   */
  renderWorlds(frameState, forHitDetection, startWorld, endWorld, worldWidth) {
    let world = startWorld;
    if (forHitDetection) {
      this.hitRenderTarget_.setSize([
        Math.floor(frameState.size[0] / 2),
        Math.floor(frameState.size[1] / 2)
      ]);
      this.helper.prepareDrawToRenderTarget(
        frameState,
        this.hitRenderTarget_,
        true
      );
    }
    this.currentFrameStateTransform_ = this.helper.makeProjectionTransform(
      frameState,
      this.currentFrameStateTransform_
    );
    do {
      for (let i = 0, ii = this.styleRenderers_.length; i < ii; i++) {
        const renderer = this.styleRenderers_[i];
        const buffers = this.buffers_[i];
        if (!buffers) {
          continue;
        }
        renderer.render(buffers, frameState, () => {
          this.applyUniforms_(buffers.invertVerticesTransform);
          this.helper.applyHitDetectionUniform(forHitDetection);
        });
      }
      translate(this.currentFrameStateTransform_, worldWidth, 0);
    } while (++world < endWorld);
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
    assert(
      this.hitDetectionEnabled_,
      "`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option."
    );
    if (!this.styleRenderers_.length || !this.hitDetectionEnabled_) {
      return void 0;
    }
    const pixel = apply(
      frameState.coordinateToPixelTransform,
      coordinate.slice()
    );
    const data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);
    const color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];
    const ref = colorDecodeId(color);
    const feature = this.batch_.getFeatureFromRef(ref);
    if (feature) {
      return callback(feature, this.getLayer(), null);
    }
    return void 0;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    if (this.sourceListenKeys_) {
      this.sourceListenKeys_.forEach(function(key) {
        unlistenByKey(key);
      });
      this.sourceListenKeys_ = null;
    }
    super.disposeInternal();
  }
};
var VectorLayer_default = WebGLVectorLayerRenderer;
export {
  Uniforms,
  VectorLayer_default as default
};
//# sourceMappingURL=ol_renderer_webgl_VectorLayer.js.map
