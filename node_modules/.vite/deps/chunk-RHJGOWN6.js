import {
  MapEventType_default,
  init_MapEventType
} from "./chunk-GRTLRQUW.js";
import {
  CollectionEventType_default,
  Collection_default,
  init_Collection,
  init_CollectionEventType
} from "./chunk-VT76Z3LM.js";
import {
  Base_default,
  init_Base,
  init_dom,
  removeNode
} from "./chunk-CCKLYGMQ.js";
import {
  assert,
  init_asserts
} from "./chunk-C4VYVIMZ.js";
import {
  getIntersection,
  init_extent
} from "./chunk-ILBZPCFR.js";
import {
  EventType_default,
  Event_default,
  ObjectEventType_default,
  Object_default,
  VOID,
  clear,
  getUid,
  init_Event,
  init_EventType,
  init_Object,
  init_ObjectEventType,
  init_events,
  init_functions,
  init_obj,
  init_util,
  listen,
  unlistenByKey
} from "./chunk-JHBMLPAT.js";
import {
  __esm,
  __export
} from "./chunk-CEQRFMJQ.js";

// node_modules/ol/control/Control.js
var Control_exports = {};
__export(Control_exports, {
  default: () => Control_default
});
var Control, Control_default;
var init_Control = __esm({
  "node_modules/ol/control/Control.js"() {
    init_Object();
    init_MapEventType();
    init_functions();
    init_events();
    init_dom();
    Control = class extends Object_default {
      /**
       * @param {Options} options Control options.
       */
      constructor(options) {
        super();
        const element = options.element;
        if (element && !options.target && !element.style.pointerEvents) {
          element.style.pointerEvents = "auto";
        }
        this.element = element ? element : null;
        this.target_ = null;
        this.map_ = null;
        this.listenerKeys = [];
        if (options.render) {
          this.render = options.render;
        }
        if (options.target) {
          this.setTarget(options.target);
        }
      }
      /**
       * Clean up.
       */
      disposeInternal() {
        removeNode(this.element);
        super.disposeInternal();
      }
      /**
       * Get the map associated with this control.
       * @return {import("../Map.js").default|null} Map.
       * @api
       */
      getMap() {
        return this.map_;
      }
      /**
       * Remove the control from its current map and attach it to the new map.
       * Pass `null` to just remove the control from the current map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../Map.js").default|null} map Map.
       * @api
       */
      setMap(map) {
        if (this.map_) {
          removeNode(this.element);
        }
        for (let i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
          unlistenByKey(this.listenerKeys[i]);
        }
        this.listenerKeys.length = 0;
        this.map_ = map;
        if (map) {
          const target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();
          target.appendChild(this.element);
          if (this.render !== VOID) {
            this.listenerKeys.push(
              listen(map, MapEventType_default.POSTRENDER, this.render, this)
            );
          }
          map.render();
        }
      }
      /**
       * Renders the control.
       * @param {import("../MapEvent.js").default} mapEvent Map event.
       * @api
       */
      render(mapEvent) {
      }
      /**
       * This function is used to set a target element for the control. It has no
       * effect if it is called after the control has been added to the map (i.e.
       * after `setMap` is called on the control). If no `target` is set in the
       * options passed to the control constructor and if `setTarget` is not called
       * then the control is added to the map's overlay container.
       * @param {HTMLElement|string} target Target.
       * @api
       */
      setTarget(target) {
        this.target_ = typeof target === "string" ? document.getElementById(target) : target;
      }
    };
    Control_default = Control;
  }
});

// node_modules/ol/layer/Group.js
var Group_exports = {};
__export(Group_exports, {
  GroupEvent: () => GroupEvent,
  default: () => Group_default
});
var GroupEvent, Property, LayerGroup, Group_default;
var init_Group = __esm({
  "node_modules/ol/layer/Group.js"() {
    init_Base();
    init_Collection();
    init_CollectionEventType();
    init_Event();
    init_EventType();
    init_ObjectEventType();
    init_asserts();
    init_obj();
    init_extent();
    init_util();
    init_events();
    GroupEvent = class extends Event_default {
      /**
       * @param {EventType} type The event type.
       * @param {BaseLayer} layer The layer.
       */
      constructor(type, layer) {
        super(type);
        this.layer = layer;
      }
    };
    Property = {
      LAYERS: "layers"
    };
    LayerGroup = class _LayerGroup extends Base_default {
      /**
       * @param {Options} [options] Layer options.
       */
      constructor(options) {
        options = options || {};
        const baseOptions = (
          /** @type {Options} */
          Object.assign({}, options)
        );
        delete baseOptions.layers;
        let layers = options.layers;
        super(baseOptions);
        this.on;
        this.once;
        this.un;
        this.layersListenerKeys_ = [];
        this.listenerKeys_ = {};
        this.addChangeListener(Property.LAYERS, this.handleLayersChanged_);
        if (layers) {
          if (Array.isArray(layers)) {
            layers = new Collection_default(layers.slice(), { unique: true });
          } else {
            assert(
              typeof /** @type {?} */
              layers.getArray === "function",
              "Expected `layers` to be an array or a `Collection`"
            );
          }
        } else {
          layers = new Collection_default(void 0, { unique: true });
        }
        this.setLayers(layers);
      }
      /**
       * @private
       */
      handleLayerChange_() {
        this.changed();
      }
      /**
       * @private
       */
      handleLayersChanged_() {
        this.layersListenerKeys_.forEach(unlistenByKey);
        this.layersListenerKeys_.length = 0;
        const layers = this.getLayers();
        this.layersListenerKeys_.push(
          listen(layers, CollectionEventType_default.ADD, this.handleLayersAdd_, this),
          listen(layers, CollectionEventType_default.REMOVE, this.handleLayersRemove_, this)
        );
        for (const id in this.listenerKeys_) {
          this.listenerKeys_[id].forEach(unlistenByKey);
        }
        clear(this.listenerKeys_);
        const layersArray = layers.getArray();
        for (let i = 0, ii = layersArray.length; i < ii; i++) {
          const layer = layersArray[i];
          this.registerLayerListeners_(layer);
          this.dispatchEvent(new GroupEvent("addlayer", layer));
        }
        this.changed();
      }
      /**
       * @param {BaseLayer} layer The layer.
       */
      registerLayerListeners_(layer) {
        const listenerKeys = [
          listen(
            layer,
            ObjectEventType_default.PROPERTYCHANGE,
            this.handleLayerChange_,
            this
          ),
          listen(layer, EventType_default.CHANGE, this.handleLayerChange_, this)
        ];
        if (layer instanceof _LayerGroup) {
          listenerKeys.push(
            listen(layer, "addlayer", this.handleLayerGroupAdd_, this),
            listen(layer, "removelayer", this.handleLayerGroupRemove_, this)
          );
        }
        this.listenerKeys_[getUid(layer)] = listenerKeys;
      }
      /**
       * @param {GroupEvent} event The layer group event.
       */
      handleLayerGroupAdd_(event) {
        this.dispatchEvent(new GroupEvent("addlayer", event.layer));
      }
      /**
       * @param {GroupEvent} event The layer group event.
       */
      handleLayerGroupRemove_(event) {
        this.dispatchEvent(new GroupEvent("removelayer", event.layer));
      }
      /**
       * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
       * @private
       */
      handleLayersAdd_(collectionEvent) {
        const layer = collectionEvent.element;
        this.registerLayerListeners_(layer);
        this.dispatchEvent(new GroupEvent("addlayer", layer));
        this.changed();
      }
      /**
       * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
       * @private
       */
      handleLayersRemove_(collectionEvent) {
        const layer = collectionEvent.element;
        const key = getUid(layer);
        this.listenerKeys_[key].forEach(unlistenByKey);
        delete this.listenerKeys_[key];
        this.dispatchEvent(new GroupEvent("removelayer", layer));
        this.changed();
      }
      /**
       * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
       * in this group.
       * @return {!Collection<import("./Base.js").default>} Collection of
       *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
       * @observable
       * @api
       */
      getLayers() {
        return (
          /** @type {!Collection<import("./Base.js").default>} */
          this.get(Property.LAYERS)
        );
      }
      /**
       * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
       * in this group.
       * @param {!Collection<import("./Base.js").default>} layers Collection of
       *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
       * @observable
       * @api
       */
      setLayers(layers) {
        const collection = this.getLayers();
        if (collection) {
          const currentLayers = collection.getArray();
          for (let i = 0, ii = currentLayers.length; i < ii; ++i) {
            this.dispatchEvent(new GroupEvent("removelayer", currentLayers[i]));
          }
        }
        this.set(Property.LAYERS, layers);
      }
      /**
       * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       */
      getLayersArray(array) {
        array = array !== void 0 ? array : [];
        this.getLayers().forEach(function(layer) {
          layer.getLayersArray(array);
        });
        return array;
      }
      /**
       * Get the layer states list and use this groups z-index as the default
       * for all layers in this and nested groups, if it is unset at this point.
       * If dest is not provided and this group's z-index is undefined
       * 0 is used a the default z-index.
       * @param {Array<import("./Layer.js").State>} [dest] Optional list
       * of layer states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       */
      getLayerStatesArray(dest) {
        const states = dest !== void 0 ? dest : [];
        const pos = states.length;
        this.getLayers().forEach(function(layer) {
          layer.getLayerStatesArray(states);
        });
        const ownLayerState = this.getLayerState();
        let defaultZIndex = ownLayerState.zIndex;
        if (!dest && ownLayerState.zIndex === void 0) {
          defaultZIndex = 0;
        }
        for (let i = pos, ii = states.length; i < ii; i++) {
          const layerState = states[i];
          layerState.opacity *= ownLayerState.opacity;
          layerState.visible = layerState.visible && ownLayerState.visible;
          layerState.maxResolution = Math.min(
            layerState.maxResolution,
            ownLayerState.maxResolution
          );
          layerState.minResolution = Math.max(
            layerState.minResolution,
            ownLayerState.minResolution
          );
          layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
          layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
          if (ownLayerState.extent !== void 0) {
            if (layerState.extent !== void 0) {
              layerState.extent = getIntersection(
                layerState.extent,
                ownLayerState.extent
              );
            } else {
              layerState.extent = ownLayerState.extent;
            }
          }
          if (layerState.zIndex === void 0) {
            layerState.zIndex = defaultZIndex;
          }
        }
        return states;
      }
      /**
       * @return {import("../source/Source.js").State} Source state.
       */
      getSourceState() {
        return "ready";
      }
    };
    Group_default = LayerGroup;
  }
});

export {
  Control_default,
  Control_exports,
  init_Control,
  GroupEvent,
  Group_default,
  Group_exports,
  init_Group
};
//# sourceMappingURL=chunk-RHJGOWN6.js.map
